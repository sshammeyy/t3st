<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mango & Mocha Game</title>
<style>
  body {
    text-align: center;
    font-family: Arial, sans-serif;
  }
  canvas {
    border: 2px solid black;
    background-color: #87CEEB; /* sky blue */
    display: block;
    margin: 20px auto;
  }
  button {
    padding: 10px 20px;
    font-size: 18px;
    margin: 10px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="characterSelect">
  <h2>Choose Your Pup üê∂</h2>
  <button onclick="startGame('mango')">Play as Mango üü†</button>
  <button onclick="startGame('mocha')">Play as Mocha üç´</button>
</div>

<canvas id="gameCanvas" width="800" height="300"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Game state
let dog, dogImg, obstacles, treats, score, gameOver, obstacleInterval, treatInterval, obstacleSpeed;
let floorX = 0;

// Moving clouds for parallax
let clouds = [];

// Images
const obstacleImgs = ["images/bone.png", "images/ball.png"];
const treatImg = new Image();
treatImg.src = "images/treat.png";

// Cloud image
const cloudImg = new Image();
cloudImg.src = "images/cloud.png"; // small cloud PNG

// Restart button
const restartBtn = document.createElement("button");
restartBtn.innerText = "üîÑ Restart";
restartBtn.style.display = "none";
document.body.appendChild(restartBtn);
restartBtn.onclick = () => {
  document.getElementById("characterSelect").style.display = "block";
  canvas.style.display = "none";
  resetGame("mango");
};

// Reset game
function resetGame(choice) {
  dog = { x: 50, y: 220, width: 50, height: 50, dy: 0, gravity: 1.5, jumpPower: -20, grounded: true };
  obstacles = [];
  treats = [];
  clouds = [];
  score = 0;
  gameOver = false;
  obstacleSpeed = 6;
  floorX = 0;

  dogImg = new Image();
  dogImg.src = choice === "mango" ? "images/mango.jpg" : "images/mocha.jpg";

  // Generate clouds
  for(let i=0; i<5; i++){
    clouds.push({ x: Math.random()*canvas.width, y: 20+Math.random()*50, speed: 1+Math.random()*1 });
  }

  restartBtn.style.display = "none";
}

// Start game
function startGame(choice) {
  document.getElementById("characterSelect").style.display = "none";
  canvas.style.display = "block";

  resetGame(choice);

  if (obstacleInterval) clearInterval(obstacleInterval);
  obstacleInterval = setInterval(() => {
    if (!gameOver) {
      const obsType = obstacleImgs[Math.floor(Math.random()*obstacleImgs.length)];
      const obsImg = new Image();
      obsImg.src = obsType;
      obstacles.push({ x: canvas.width, y: 230, width: 40, height: 40, img: obsImg });
    }
  }, 2000);

  if (treatInterval) clearInterval(treatInterval);
  treatInterval = setInterval(() => {
    if (!gameOver) {
      treats.push({ x: canvas.width, y: 200 + Math.random()*40, width: 30, height: 30 });
    }
  }, 3000);

  requestAnimationFrame(gameLoop);
}

// Jump function
function jump() {
  if (dog && dog.grounded && !gameOver) {
    dog.dy = dog.jumpPower;
    dog.grounded = false;
  }
}

// Controls
document.addEventListener("keydown", e => { if(e.code === "Space") jump(); });
canvas.addEventListener("mousedown", jump);
canvas.addEventListener("touchstart", e => { e.preventDefault(); jump(); }, { passive:false });

// Game loop
function gameLoop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(gameOver){
    ctx.fillStyle="red";
    ctx.font="30px Arial";
    ctx.textAlign="center";
    ctx.fillText("Game Over!", canvas.width/2,120);
    ctx.fillStyle="black";
    ctx.font="20px Arial";
    ctx.fillText("Final Score: "+score, canvas.width/2,160);
    restartBtn.style.display="inline-block";
    return;
  }

  // Move and draw clouds
  clouds.forEach(c=>{
    c.x -= c.speed;
    if(c.x<-100) c.x=canvas.width+50;
    ctx.drawImage(cloudImg, c.x, c.y, 80, 40);
  });

  // Move floor
  floorX -= obstacleSpeed;
  if(floorX <= -canvas.width) floorX = 0;

  // Draw floor
  ctx.fillStyle="#6c4c3f";
  ctx.fillRect(floorX, 270, canvas.width, 30);
  ctx.fillRect(floorX+canvas.width, 270, canvas.width, 30);

  // Dog physics
  dog.y += dog.dy;
  if(dog.y + dog.height >= 270){ dog.y=220; dog.dy=0; dog.grounded=true; }
  else dog.dy += dog.gravity;

  // Draw dog
  ctx.drawImage(dogImg, dog.x, dog.y, dog.width, dog.height);

  // Obstacles
  obstacles.forEach((obs)=>{
    obs.x -= obstacleSpeed;
    ctx.drawImage(obs.img, obs.x, obs.y, obs.width, obs.height);
    if(dog.x < obs.x + obs.width && dog.x + dog.width > obs.x && dog.y < obs.y + obs.height && dog.y + dog.height > obs.y){
      gameOver=true;
      clearInterval(obstacleInterval);
      clearInterval(treatInterval);
    }
  });
  obstacles = obstacles.filter(obs => obs.x > -obs.width);

  // Treats
  treats.forEach((treat, idx)=>{
    treat.x -= obstacleSpeed;
    ctx.drawImage(treatImg, treat.x, treat.y, treat.width, treat.height);
    if(dog.x < treat.x + treat.width && dog.x + dog.width > treat.x && dog.y < treat.y + treat.height && dog.y + dog.height > treat.y){
      score += 50; // bonus points
      treats.splice(idx,1);
    }
  });
  treats = treats.filter(treat => treat.x > -treat.width);

  // Score
  score++;
  ctx.fillStyle="black";
  ctx.font="20px Arial";
  ctx.textAlign="left";
  ctx.fillText("Score: "+score, 20,30);

  // Gradually increase difficulty
  if(score % 200 === 0) obstacleSpeed += 0.3;

  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
